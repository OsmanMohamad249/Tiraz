name: CI Smoke E2E - Measurements

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  smoke-e2e-measurements:
    name: Smoke E2E - /api/v1/measurements/process
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies (jq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Load CI Environment Variables
        id: load_env
        run: |
          # Load .ci/.ci.env content into a variable for use in docker-compose
          if [ -f .ci/.ci.env ]; then
            ENV_VARS=$(cat .ci/.ci.env | xargs)
          else
            ENV_VARS=""
          fi
          echo "ENV_VARS=$ENV_VARS" >> $GITHUB_OUTPUT

      - name: Create docker-compose.ci.yml
        run: |
          # Generate a CI-specific docker-compose file that mounts uploads to the runner
          cat > docker-compose.ci.yml <<'YAML'
          version: '3.8'
          services:
            postgres:
              image: postgres:15
              environment:
                POSTGRES_USER: ${POSTGRES_USER}
                POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
                POSTGRES_DB: ${POSTGRES_DB}
              ports:
                - "5432:5432"
              healthcheck:
                test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
                interval: 10s
                timeout: 5s
                retries: 5
              volumes:
                - postgres-data:/var/lib/postgresql/data

            redis:
              image: redis:7
              ports:
                - "6379:6379"

            backend:
              build:
                context: .
                dockerfile: backend/Dockerfile
              ports:
                - "8000:8000"
              environment:
                - PYTHONUNBUFFERED=1
                - DATABASE_URL=postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
                - SECRET_KEY=${SECRET_KEY}
                - AI_SERVICE_URL=${AI_SERVICE_URL}
                - CORS_ORIGINS=http://localhost:3000,http://localhost:8080
                - REDIS_URL=redis://redis:6379/0
              volumes:
                - ./backend:/app
                - ./backend/uploads:/app/uploads
              depends_on:
                postgres:
                  condition: service_healthy
                redis:
                  condition: service_started

            ai-models:
              build:
                context: ./ai-models
                dockerfile: Dockerfile
              ports:
                - "8001:8000"
              environment:
                - PYTHONUNBUFFERED=1
                - PORT=8000
              volumes:
                - ./ai-models:/app
                - ./ai-models/data:/app/data

          volumes:
            postgres-data:
          YAML

      - name: Build and Run Services
        run: |
           ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml up --build --wait --timeout 120s

      - name: Run Smoke Tests
        run: |
          # Use the loaded environment variables for docker-compose exec
          ${{ steps.load_env.outputs.ENV_VARS }} docker-compose -f docker-compose.ci.yml exec -T backend pytest tests/smoke_tests.py

      - name: Collect CI logs and artifacts
        if: always()
        run: |
          set -euo pipefail

          ART_DIR=ci-artifacts
          mkdir -p "$ART_DIR"
          echo "Collecting docker-compose logs..."
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml logs --no-color --timestamps > "$ART_DIR/compose.log" || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml logs --no-color --timestamps backend > "$ART_DIR/backend.log" || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml logs --no-color --timestamps ai-models > "$ART_DIR/ai-models.log" || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml logs --no-color --timestamps postgres > "$ART_DIR/postgres.log" || true

          echo "Attempting to copy alembic logs from backend container or filesystem..."
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T backend bash -lc 'cp /app/alembic.log /tmp/alembic_from_container.log 2>/dev/null || true' || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T backend bash -lc 'cp /workspaces/Qeyafa/backend/alembic.log /tmp/alembic_from_container_fs.log 2>/dev/null || true' || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp backend:/tmp/alembic_from_container.log "$ART_DIR/alembic.log" >/dev/null 2>&1 || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp backend:/tmp/alembic_from_container_fs.log "$ART_DIR/alembic_from_fs.log" >/dev/null 2>&1 || true

          echo "Running alembic inside backend container to capture migration logs (idempotent)"
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T backend bash -lc 'python -m alembic upgrade head 2>&1 | tee /tmp/alembic_run.log || true' || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp backend:/tmp/alembic_run.log "$ART_DIR/alembic_run.log" >/dev/null 2>&1 || true

            echo "Running Postgres version check into postgres_version.txt (via postgres container)..."
            ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T postgres bash -lc "psql -U \${POSTGRES_USER} -d \${POSTGRES_DB} -c \"SELECT version();\" > /tmp/postgres_version.txt 2>&1 || true" || true
            ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp postgres:/tmp/postgres_version.txt "$ART_DIR/postgres_version.txt" >/dev/null 2>&1 || true

            echo "Dumping users (first 200 rows) to users-after-migrations.csv via postgres container..."
            ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T postgres bash -lc "psql -U \${POSTGRES_USER} -d \${POSTGRES_DB} -c \"COPY (SELECT id, email, role, created_at FROM users ORDER BY created_at DESC LIMIT 200) TO STDOUT WITH CSV HEADER\" > /tmp/users-after-migrations.csv 2>&1 || true" || true
            ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp postgres:/tmp/users-after-migrations.csv "$ART_DIR/users-after-migrations.csv" >/dev/null 2>&1 || true

          echo "Ensuring tester.log exists (best-effort)..."
          if [ -f tester.log ]; then
            cp tester.log "$ART_DIR/tester.log" || true
          else
            echo "Running lightweight backend connectivity check into tester.log"
            curl -sS -w "\n%{http_code}" http://localhost:8000/health > "$ART_DIR/tester.log" || true
          fi

          echo "Attempting to copy uploads directory from backend container (if present)..."
          if [ -d ./backend/uploads ]; then
            tar -czf "$ART_DIR/uploads.tgz" -C ./backend uploads || true
          else
            ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp backend:/app/uploads "$ART_DIR/uploads" >/dev/null 2>&1 || true || true
            if [ -d "$ART_DIR/uploads" ]; then
              tar -czf "$ART_DIR/uploads.tgz" -C "$ART_DIR" uploads || true
            fi
          fi

          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T backend bash -lc 'ls -la /tmp || true' > "$ART_DIR/backend_tmp_listing.log" || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T ai-models bash -lc 'ps aux || true' > "$ART_DIR/ai-models-process-listing.log" || true
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml cp ai-models:/tmp/ai-models.log "$ART_DIR/ai-models.tmp.log" >/dev/null 2>&1 || true

          tar -czf ci-logs.tar.gz -C "$ART_DIR" . || true
        shell: bash
      - name: Upload CI logs artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: smoke-ci-logs
          path: ci-logs.tar.gz

      - name: Verify DB persistence (query from backend)
        run: |
          set -euo pipefail
          echo "Verifying measurement was persisted in DB (using backend container)"
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml exec -T backend bash -lc "export TEST_EMAIL='${TEST_EMAIL}'; python /workspaces/Qeyafa/backend/ci/check_db.py"

      - name: Tear down compose services
        if: always()
        run: |
          ${{ steps.load_env.outputs.ENV_VARS }} docker compose --env-file .ci/.ci.env -f docker-compose.ci.yml down -v
