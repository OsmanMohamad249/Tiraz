name: CI Smoke E2E - Measurements

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  smoke-e2e-measurements:
    name: Smoke E2E - /api/v1/measurements/process
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install dependencies (jq)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl

      - name: Start Docker Compose services
        env:
          SECRET_KEY: ${{ secrets.CI_SECRET_KEY }}
        run: |
          export SECRET_KEY="$SECRET_KEY"
          docker compose up --build -d

      - name: Wait for backend health
        run: |
          echo "Waiting for backend /health..."
          for i in {1..40}; do
            if curl -sS http://localhost:8000/health | grep -q '"status":"ok"'; then
              echo "backend healthy"; break
            fi
            sleep 3
          done
          curl -sS http://localhost:8000/health

      - name: Run measurements process smoke test
        run: |
          set -euo pipefail
          # make a unique test email per run
          TEST_EMAIL="ci_smoke+${GITHUB_RUN_ID}@example.com"
          export TEST_EMAIL
          echo "Using TEST_EMAIL=$TEST_EMAIL"

          # create tiny PNG (1x1 transparent) to POST
          IMG_B64='iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII='
          echo "$IMG_B64" | base64 -d > front.png
          cp front.png back.png left.png right.png

          # register (ignore error if already exists)
          curl -sS -X POST http://localhost:8000/api/v1/auth/register \
            -H 'Content-Type: application/json' \
            -d "{\"email\":\"${TEST_EMAIL}\",\"password\":\"password123\",\"first_name\":\"CI\",\"last_name\":\"Smoke\",\"role\":\"customer\"}" || true

          # login and obtain token
          TOKEN=$(curl -sS -X POST http://localhost:8000/api/v1/auth/login -d "username=${TEST_EMAIL}&password=password123" | jq -r .access_token)
          if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
            echo "Failed to login or obtain token"; exit 1
          fi

          # POST to /api/v1/measurements/process
          RESP=$(curl -s -w "\n%{http_code}" -X POST http://localhost:8000/api/v1/measurements/process \
            -H "Authorization: Bearer $TOKEN" \
            -F "photo_front=@front.png" -F "photo_back=@back.png" -F "photo_left=@left.png" -F "photo_right=@right.png" \
            -F "height=170" -F "weight=70")

          HTTP_STATUS=$(tail -n1 <<< "$RESP")
          BODY=$(sed '$d' <<< "$RESP")
          echo "HTTP status: $HTTP_STATUS"
          echo "$BODY" | jq -C . || true
          if [ "$HTTP_STATUS" != "200" ]; then
            echo "Process endpoint did not return 200"; exit 1
          fi
          # ensure expected keys exist
          echo "$BODY" | jq -e '.measurements and .confidence_score' >/dev/null

          # Extract measurement id for further integration checks
          MEASUREMENT_ID=$(echo "$BODY" | jq -r .id)
          echo "Created measurement id: $MEASUREMENT_ID"

          # Update measurement (change chest measurement)
          UPDATE_PAYLOAD='{"measurements": {"chest": 111.0, "waist": 80.0, "hip": 98.0}}'
          UPD_RESP=$(curl -s -w "\n%{http_code}" -X PUT http://localhost:8000/api/v1/measurements/${MEASUREMENT_ID} \
            -H "Authorization: Bearer $TOKEN" -H 'Content-Type: application/json' \
            -d "$UPDATE_PAYLOAD")
          UPD_STATUS=$(tail -n1 <<< "$UPD_RESP")
          UPD_BODY=$(sed '$d' <<< "$UPD_RESP")
          echo "Update HTTP status: $UPD_STATUS"
          echo "$UPD_BODY" | jq -C . || true
          if [ "$UPD_STATUS" != "200" ]; then
            echo "Failed to update measurement"; exit 1
          fi
          echo "$UPD_BODY" | jq -e '.measurements.chest == 111.0' >/dev/null

          # Delete measurement
          DEL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE http://localhost:8000/api/v1/measurements/${MEASUREMENT_ID} \
            -H "Authorization: Bearer $TOKEN")
          echo "Delete HTTP status: $DEL_STATUS"
          if [ "$DEL_STATUS" != "204" ]; then
            echo "Failed to delete measurement"; exit 1
          fi

          # Confirm deletion: GET should return 404
          GET_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -X GET http://localhost:8000/api/v1/measurements/${MEASUREMENT_ID} \
            -H "Authorization: Bearer $TOKEN")
          echo "Get after delete HTTP status: $GET_STATUS"
          if [ "$GET_STATUS" != "404" ]; then
            echo "Measurement still exists after delete"; exit 1
          fi

          # Negative AI response: force AI service to return unsuccessful status
          NEG_RESP=$(curl -s -w "\n%{http_code}" -X POST http://localhost:8000/api/v1/measurements/process \
            -H "Authorization: Bearer $TOKEN" \
            -F "photo_front=@front.png" -F "photo_back=@back.png" -F "photo_left=@left.png" -F "photo_right=@right.png" \
            -F "height=170" -F "weight=70" -F "force_error=error")
          NEG_STATUS=$(tail -n1 <<< "$NEG_RESP")
          NEG_BODY=$(sed '$d' <<< "$NEG_RESP")
          echo "Negative AI HTTP status: $NEG_STATUS"
          echo "$NEG_BODY" | jq -C . || true
          # Expect backend to respond with 500 when AI returns unsuccessful status
          if [ "$NEG_STATUS" != "500" ]; then
            echo "Negative AI scenario did not return expected 500"; exit 1
          fi

      - name: Verify DB persistence (query from backend)
        run: |
          set -euo pipefail
          echo "Verifying measurement was persisted in DB (using backend container)"
          docker compose exec -T backend bash -lc "export TEST_EMAIL='${TEST_EMAIL}'; python /workspaces/Qeyafa/backend/ci/check_db.py"

      - name: Tear down compose services
        if: always()
        run: |
          docker compose down -v
